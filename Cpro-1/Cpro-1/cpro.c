#include<stdio.h>
//
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	printf("%p\n", arr);
//	printf("%p\n", i);
//	for (i = 0; i <= 12; i++)//死循环
//		//原因 在不同环境下内存开辟空间的方式不同
//		//Debug下会死循环 Releas下不会死循环
//		//在Debug情况下 i的地址大于arr首元素的地址
//		//因为栈开辟空间是从高到低开辟的 i的地址比arr大 导致
//		//arr向上越界时会覆盖到i上 说明Relase对于内存开辟有所优化 跟编译器有关
//	{
//		arr[i] = 0;
//		//printf("hehe\n");
//	}
//	return 0;
//}


//整形家族：char short int long longlong 都存在有符号和无符号
//浮点数：float double
//自定义  枚举 结构体
//整数的二进制的三种表现形式 原码反码补码
//20: 
//反码=原码符号位不变其他按位取反 补码=反码+1
//一般数值都用补码来存储 正数的原反补相同
//大端字节序存储：一个字节序 把高位字节序放在低位 把高位字节序放在低位
//小端字节序存储： 跟大端反着
//
//int main()//判断大小端存储
//{
//	int a = 1;//00 00 00 01
//	int b = *(char*)&a;
//	if (b == 0) {
//		printf("大端");
//	}
//	else {
//		printf("小端");
//	}
//	return 0;
//}
//int main()
//{
//	char a[1000] = { 0 };
//	int i = 0;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;//a0=-1-0=-1 a1=-1-1=-2 .....a999=-1-999=-1000
//	}
//	printf("%d", strlen(a));
//	return 0;
//}

//5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果：
//A选手说：B第二，我第三；
//B选手说：我第二，E第四；
//C选手说：我第一，D第二；
//D选手说：C最后，我第三；
//E选手说：我第四，A第一；
//比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。
//int main()
//{
	//int arr[5] = { 1,2,3,4,5 };
	//int a, b, c, d, e, ret;
	//int i = 0;
	//int j = 0;
	//int count = 0;
	//for (i = 0; i < 3; i++) {
	//	for (j = i+1; j < 5; j++) {
	//		if (arr[i] == arr[j]) {
	//			count++;//如果有不一样的就返回0
	//		}
	//	}
	//}
	//printf("%d", count);
	//while (1) {

	//}
//	//return 0;
//	int a[5];
//	for (a[0] = 1; a[0] <= 5; a[0]++)//A
//	{
//		for (a[1] = 1; a[1] <= 5; a[1]++)//B
//		{
//			for (a[2] = 1; a[2] <= 5; a[2]++)
//			{
//				for (a[3] = 1; a[3] <= 5; a[3]++)
//				{
//					for (a[4] = 1; a[4] <= 5; a[4]++)
//					{
//						if (
//							(a[1] == 2) + (a[0] == 3) == 1 &&
//							(a[1] == 2) + (a[4] == 4) == 1 &&
//							(a[2] == 1) + (a[3] == 2) == 1 &&
//							(a[2] == 5) + (a[3] == 3) == 1 &&
//							(a[4] == 4) + (a[0] == 1) == 1 &&
//							a[0] * a[1] * a[2] * a[3] * a[4] == 120
//							)
//						{
//							printf("A B C D E\n");
//							printf("%d %d %d %d %d", a[0], a[1], a[2], a[3], a[4]);
//						}
//					}
//				}
//			}
//		}
//	}
//	return 0;
//}
//思路：1.列出所有可能 A B C D E都第一句话对 A B C D 第一句话对 E第二句话对.......
//2.把所有可能都列出来之后依次给他们赋值，并将其存放到一个数组里 遍历数组 是否为1 2 3 4 5 是 则通过.


//以下为4个嫌疑犯的供词:
//a说：不是我。a == 0 b==0
//b说：是c。 c == 1
//c说：是d。 d == 1
//d说：c在胡说 d == 0
//已知3个人说了真话，1个人说的是假话。
//c跟d 必定有一个人假

//
//int main()
//{
//	int killer = 0;
//	for (killer = 'a'; killer <= 'd'; killer++)
//	{
//		if ((killer != 'a') + (killer == 'c') + (killer == 'd') + (killer != 'd') == 3)
//		{
//			printf("凶手是:%c", killer);
//		}
//	}
//	return 0;
//}

//int main()//杨辉三角
//{
//	int arr[5][50];
//	int arr[0][0] = 1;
//	int arr[1][0] = 1;
//	int arr[1][1] = 1;
//	for (int i = 2; i < 5; i++)
//	{
//		for (int j = 0; j < 100; j++)
//		{
//			arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
//		}
//	}
//	return 0;
//}
