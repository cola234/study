#include<stdio.h>
#include<Windows.h>
/*int main()
{
	unsigned int i;
	for (i = 9; i >= 0; i--)
	{
		printf("%u\n", i);
		Sleep(1000);
	}
}	*/														
//0的补码 unsigned int i = 00000000 00000000 00000000 00000000
//1的补码 unsigned int i = 00000000 00000000 00000000 00000001
//4294967295的二进制:      11111111 11111111 11111111 11111111


int main()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("%d\n", n);//9
	printf("%f\n", *pFloat);//0.000000
	*pFloat = 9.0;
	printf("%d\n", n);//1091567616
	printf("%f\n", *pFloat);//9.000000
}
/*浮点数存储规则 IEEE754（）
V = (-1)^S  *    M     *    2^E
     符号位   有效数字    指数位

例： V = 5.0f ---> 101.0 ---> 1.01*2^2
也就是  (-1)^0(S) * 1.01(M) * 2^2(E)
V = 9.5f 如何写成二进制
先写小数点前面的数：1001 在写小数点后面的数
注意：权重 对于一个二进制来说 1001.10 小数点前面数的权重为2^0 2^1  ……递增
小数点后面的数的权重为2^-1  2^-2次 也就是说 小数点后一位表示为0.5
所以9.5f写为二进制 应是1001.1
也就是 -1^0 * 1.0011 * 2^3
有些数是没法算的 例：V = 9.6f
规定：对于float类型的数据E可以存8个bit位的数据 而8个bit位置最高可以存255
所以对于E来说 往数据中存储的数据需要在真实值的基础上+上一个中间值
float类型的数据需要+上127
double类型需要+上1023

规定2：对于M而言 由于M的取值恒＞=1且＜2  所以M中的首位1可以省略 只需要存
小数点后面的数即可 这样的好处是可以节省一位的存储空间
注意：一个小数 将其转换为二进制数 和其存到内存中的二进制序列 是不可以划等号的

规定3：当E中存储的值不为全0或不为全1时 真实值直接减去127或者1023 M中取出的数补1 在用公式还原出真实值
当E中存储的值为全0时 真实值直接为1-127 或 1 - 1023 M中取出的数无需补1 直接还原成0.xxxx的小数 这样是为了表示正负0 以便接近于0的很小的数字
当E中存储的值为全1时 如果M中全为0 表示无穷大

再次以float = 5.5为例
101.1  
S M E  -1^0 * 1.011 * 2^2
S=0
M=011
E=2+127=129=10000001
存到内存中则是 0100 0000 1011 0000 0000 0000 0000 0000
写成16进制就是0x40b00000 
这里位数不够时 要在后面补0 注意是后面不是前面 因为011实际上是小数 在高位补齐会导致数的大小发生变化！
*/

//int main()//将一个数组 左边放奇数右边放偶数
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int left = 0;
//	int right = sz - 1;
//	while (left<right)
//	{
//		while (left < right && arr[left] % 2 == 0)//找左边 如果左边找到 让left变成找到的下标
//		{
//			left++;
//		}
//		while (left<right && arr[right]%2 != 0)//找右边 右边找到 让right变成找到的下标
//		{
//			right--;
//		}
//		int tmp = 0;
//		tmp = arr[left];
//		arr[left] = arr[right];
//		arr[right] = tmp;
//	}
//	for (int i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}
//merge(int arr1[1000], int arr2[1000],int arr3[1000])
//{
//	//1 2 5 7 9	
//	//5 6 7 8 9 10
//	int left1 = 0;
//	int left2 = 0;
//	int i = 0
//	if (arr1[left1] < arr2[left2])
//	{
//		arr3[i] = arr1[left1];
//		left1++;
//	}
//	else
//	{
//		arr3[i] = arr2[left2];
//		left2++;
//	}
//}
//int main()//升序序列合并
//{
//	int n = 0;
//	int m = 0;
//	scanf("%d %d", &n, &m);
//	int arr1[1000];
//	int arr2[1000];
//	int arr3[1000]
//	for (int i = 0; i < n; i++)
//	{
//		scanf("%d",arr1[i]);
//	}
//	for (int i = 0; i < m; i++)
//	{
//		scanf("%d", arr2[i]);
//	}
//	merge(arr1, arr2,arr3);
//}